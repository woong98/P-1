# 2022.01.10 정리

### nodejs - mysql 연결
```javascript=
let mysql = require('mysql2');

let con = mysql.createConnection(
  {
    host:"localhost",
    user:"nodejs",
    password: '545493',
    port : "3306",
    database : "mongsite"
  }
)

con.connect(function(err)
{
  if (err) throw err;
  console.log("connected");
})
```
연결이 성공한 코드이다.
- <strong>connect ECONNREFUSED 127.0.0.1:3306의 에러가 nodejs에서 mysql에 접근하는데 발생했다.</strong>
-> 이 경우에는 mysql 재설치를 통해서 해결했다. 처음에 설치하는 과정에서 port를 임의의 값으로 설정했기 때문에 발생한 문제로 추측
</br>
- <strong>ACCESS DENIED 오류가 발생했다.</strong>
-> 이 경우는 생활코딩 nodejs/mysql 강의를 참고하여 해결하였다.
</br>
- <strong>nodejs Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client 이 발생했다</strong>
-> 구글링을 통해서 알아본 결과, mysql의 경우에는 기본적으로 비동기적 접근을 허용하지 않기 때문에 mysql2 모듈을 사용해서 접근해야 한다는 것을 알 수 있었다. 이를 바탕으로 위의 코드로 연결을 성공했다. 


### DB 관련 명령어 정리 
- show databases; 
데이터베이스 출력(스키마)
- show column from <테이블이름>; 
테이블 속성?출력 
- INSERT INTO 테이블이름(필드이름1, 필드이름2, 필드이름3, ...) VALUES (데이터값1, 데이터값2, 데이터값3, ...); 
테이블에 요소를 추가 

### query문 

```javascript=
con.connect(function(err) { //연결 완료시에는 connect에 대한 function을 실행해준다. 
  if (err) throw err;
  console.log("Connected!");
  con.query("CREATE DATABASE mydb", function (err, result) {
    if (err) throw err; 
    console.log("Database created");
  });
});
```
- query()의 경우에는 현재 인수로 두 가지를 가지는데, <strong>query문(SQL 명령어)</strong>과 <strong>콜백함수</strong>이다. 콜백함수 또한 query가 실행되는 경우에 호출된다.

```javascript=
con.query("SELECT * FROM free", function(err, result, fields)
  { //query문에서의 function에대한 정보를 찾아봐야 할 듯 
    if (err) throw err;
    console.log(result);
  });
  //서버에서 table에 접근해서 정보를 불러올 수 있음 
```
- 위의 코드를 이용하면, result안에 테이블에 있는 정보를 가져올 수 있음. 배열 형태로 가져온다. 
```
[
  { id: 1, writer: 'master' },
  { id: 2, writer: 'master' },
  { id: 3, writer: 'master' } 
]
```

### 커넥션
1. 웹브라우저가 서버 URL에서 호스트명을 추출
2. 이를 바탕으로 IP주소 반환(by DNS)
3. port번호도 알아내고
4. 브라우저와 웹서버가 TCP Connection을 맺는다
5. 서로 HTTP 요청 및 응답 과정
6. 커넥션을 닫으면 브라우저가 페이지를 보여준다. 

## axios 
- 브라우저, Node.js를 위한 Promise API를 활용하는 HTTP 비동기 통신 라이브러리. 현재 우리는 비동기 방식이 필요하고, 또한 SPA 방식을 사용하기 때문에 적재적소에 HTTP 메시지를 날릴 필요가 있다(자유게시판을 불러오고 싶은 경우도 당장 이게 필요함)
```javascript=
const axios = require('axios');

axios.get('/user?ID=12345') //이 url을 history api로 지정한 방식과 비슷하게 사용
  .then(function (response) {
    // 성공 핸들링
    console.log(response);
  })
  .catch(function (error) {
    // 에러 핸들링
    console.log(error);
  })
  .then(function () {
    // 항상 실행되는 영역
  });
```

### express사용 

- express의 경우에는 서버를 구성할 때 좀 더 간결하고 효과적으로 구성할 수 있다. 

- 처음으로 로컬에 접근한 경우에 HTML파일을 전송해야 하는데, 그 부분에 대해서 express API를 찾아봤다.

- 라우팅을 get을 통해서 실행해준 후, 이를 바탕으로 응답을 파일 형태로 해야하는데(맨 처음), 이 경우에는 sendFile이라는 메소드를 참조해보았다.

<strong> res.sendFile(path [, options] [, fn])</strong>

```javascript=
app.get('/', function(req, res) 
{
    return res.sendFile('/mong.html');
});
```
- 잘 될줄 알았지만, sendFile 메소드의 경우에는 미들웨어의 영향으로 인해서 절대경로만을 지원한다. 이때문에 코드를 다음과 같이 변경하였다.

```javascript=
const path = require('path');
app.get('/', function(req, res)
{
    res.sendFile(path.join(__dirname, '/mong.html'));
});
```
- 이 경우 또 문제가 생긴게, 다른 link된 파일들은 같이 안가고 오직 이 html파일만 전송이 된다는거였다... 

```javascript=
let app = express();
app.use(express.static(__dirname));
app.get('/', function(req, res)
{
    res.sendFile(path.join(__dirname, '/mong.html'));
});

```
- static 부분을 설정해서, html파일이 link된 파일을 찾을 수 있도록 현재 디렉토리로 경로를 설정해준다. 이 경우에는 올바르게 관련된 모든 파일을 얻을 수 있었다. 


## 궁금한 것 
- 그러면 데이터베이스에서 어떤 식으로 데이터를 가지고 오는가?
-> 이거는 이제 SELECT라는 SQL 명령을 이용해서 가져올 수 있다. 
- 연결이 시작되는 시점과 끝나는 시점은 어떻게 결정되어야 하는가?
-> 이거는 HTTP 메시지를 request를 탐지하고, 또 서버사이드에서 respond하는 과정이 끝나게 된다면 이 때. 
- History API를 사용하는 경우, 글쓰기로 데이터베이스에 글이 추가되는 상황에서 뒤로가기를 통해서 맨 처음 게시판으로 이동하는 경우에, 결과는 어떻게 되는가? 
-> 해봐야알듯 
- 이러한 모듈은 어디서 찾을 수 있을까?

- 서버에서 새로운 정보를 받아오는 경우에는, 화면을 refresh하라는 정보가 전송되어야 할 것 같은데, 이거는 HTTP메시지를 활용하여 전달되는건가. 아니면 파일에 바뀐점을 브라우저에서 탐지하여 알아서 변경? 

- 서버에서 DB에 접근하는 형식을 가지기 때문에, 일단 서버 내부에 DB와 connection을 형성하는 코드를 넣는 식으로 해야되는건가
-> 이를 위해서 Axios를 사용하게 되었다. axios를 통해서 서버에 정보를 요청한다. 서버는 요청받은것을 라우팅해서 DB에서 적절한 테이블에 접근한다. 요런 메커니즘으로 가야할듯 

- 클라이언트 사이드에서 require을 인식하지 못하는 문제를 발견했다. 이는 내일 해결해보도록 하겠다! 